<?php
/**
 * @file
 * Provides hooks for Views GeoJSON map layer.
 */

/**
 * Implements hook_layer_content_alter().
 *
 * See MapLayerController->buildContent();
 */
function nexteuropa_map_viewsgeojson_layer_content_alter(&$content, $wrapper, $entity) {

  // Fetches map data from Views GeoJSON layer.
  if ($entity->type == 'viewsgeojson_layer') {
    $settings = drupal_json_decode($wrapper->settings->value());

    // Fetches nodes using chosen filters.
    $filters = $settings['node_filters'];
//    $nodes = _nexteuropa_map_viewsgeojson_fetch_viewsgeojsons($filters);
//    if ($nodes) {
//      $items = array();
//      foreach ($nodes as $node) {
//        $title = $node->title;
//
//        // Prepares the node to render the pop-up using the chosen view mode.
//        $view_mode = isset($settings['view_mode']) ? $settings['view_mode'] : 'teaser';
//        $node_view = node_view($node, $view_mode);
//
//        // Gets all the field values.
//        $field_items = field_get_items('node', $node, $filters['geofield']);
//        $items[] = array(
//          'field_items' => $field_items,
//          'title' => $title,
//          'popup' => drupal_render($node_view),
//        );
//      }
//
//      $features = array();

      // Prepares the geo features based on the geofield type that they are
      // stored in.
      $type = field_info_field($filters['geofield'])['type'];
      if ($type == 'geofield') {
        $features = _nexteuropa_map_viewsgeojson_prepare_features($items);
      }
      elseif ($type == 'geofield_geojson') {
        foreach ($items as $key => $item) {
          $geojson_features = drupal_json_decode($item['field_items'][0]['geofield_geojson']);
          foreach ($geojson_features['features'] as $geojson_feature) {
            $features[] = $geojson_feature;
          }
        }
      }

      $layers[] = array(
        'layer_settings' => $settings,
        'label' => $wrapper->title->value(),
        'features' => $features,
        'id' => _nexteuropa_map_layer_id($wrapper->title->value()),
      );
      $content['#attached']['js'][] = array(
        'data' => array(
          'viewsgeojson_layers' => $layers,
        ),
        'type' => 'setting',
      );
    }
    return $content;
//  }
}

/**
 * Implements hook_map_content_alter().
 *
 * See MapController->buildContent().
 */
function nexteuropa_map_viewsgeojson_map_content_alter(&$custom_js) {
  $viewsgeojson_layer_js = base_path() . drupal_get_path('module', 'nexteuropa_map_viewsgeojson') . "/js/viewsgeojson_layer.js?v=" . rand(0, 33333);
  $custom_js[] = $viewsgeojson_layer_js;
  return $custom_js;
}

/**
 * Implements hook_layer_inline_entity_form_alter().
 *
 * See MapLayerInlineEntityFormController->EntityForm().
 */
function nexteuropa_map_viewsgeojson_layer_inline_entity_form_alter(&$entity_form, $settings, $type) {
  if ($type == 'viewsgeojson_layer') {
    // Defines the form elements shared by inline entity and stand alone form.
    $entity_form = _nexteuropa_map_viewsgeojson_shared_form($entity_form, $settings);
  }
  return $entity_form;
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Alters the stand alone entity form with Views GeoJSON layer specific fields. See also
 * inline entity form. Shares  form elements with the inline entity form.
 */
function nexteuropa_map_viewsgeojson_form_map_layer_form_alter(&$form, &$form_state, $form_id) {
  dsm('kasjdkjsa');

  dpm($form_state['map_layer']);

  if ($form_state['map_layer']->type == 'viewsgeojson_layer') {

    // Defines the form elements shared by inline entity and stand alone form.
    $settings = $form_state['settings'];
    $form = _nexteuropa_map_viewsgeojson_shared_form($form, $settings);
  }
}

/**
 * Provides shared form elements.
 *
 * Form elements that are shared by the stand-alone and the inline entity form.
 *
 * @param array $form
 *   The form before adding the shared elements.
 * @param array $settings
 *   The map settings that can hold default values.
 *
 * @return
 *   The form with the shared elements added.
 */
function _nexteuropa_map_viewsgeojson_shared_form(&$form, $settings) {
  $form['#tree'] = TRUE;

  // Adds pop up fields.
  $form['popup'] = _nexteuropa_map_map_form_elements('popup', $settings);

  // Adds clustering fields.
  $form['clustering'] = _nexteuropa_map_map_form_elements('clustering', $settings);

  // Adds attribution fields.
  $form['attribution'] = _nexteuropa_map_map_form_elements('attribution', $settings);

  // Adds icon fields.
  $form['icon'] = _nexteuropa_map_map_form_elements('icon', $settings);

  // Adds a filter fieldset.
//  $form['node_filters'] = array(
//    '#type' => 'fieldset',
//  );

//  _nexteuropa_map_viewsgeojson_get_views();

  // Adds map content type filter field.
//  $form['node_filters']['map_content_type'] = array(
//    '#type' => 'select',
//    '#options' => _nexteuropa_map_viewsgeojson_get_content_types(),
//    '#title' => t('Content type'),
//    '#description' => t('Content type that contains the geospatial data'),
//    '#default_value' => isset($settings['node_filters']['map_content_type']) ? $settings['node_filters']['map_content_type'] : 0,
//  );

  // Provides a geofield selection field to choose in which field to find geo
  // data.
//  $geofield_options = array();
//  foreach (_nexteuropa_map_viewsgeojson_get_content_types() as $key => $content_type) {
//    foreach (_nexteuropa_map_viewsgeojson_get_geofields($key) as $key => $field) {
//      $geofield_options[$key] = $field;
//    }
//  }

  // @todo make dependent on content type.
//  $form['node_filters']['geofield'] = array(
//    '#type' => 'select',
//    '#options' => $geofield_options,
//    '#title' => t('Geofield'),
//    '#description' => t('Field that contains the geospatial data'),
//    '#default_value' => isset($settings['node_filters']['geofield']) ? $settings['node_filters']['geofield'] : 0,
//  );


  $form['viewsgeojson_url'] = array(
    '#title' => t('Views GeoJSON URL'),
    '#type' => 'textfield',
    '#size' => 60,
    '#default_value' => isset($settings['viewsgeojson_url']) ? $settings['viewsgeojson_url'] : NULL,
    '#required' => TRUE,
    '#description'=>t('URL of the GeoJSON view'),
  );

  // Provides taxonomy term filter fields based on vocabularies.
//  $taxonomy_fields = _nexteuropa_map_viewsgeojson_get_taxonomy_fields();
//  foreach ($taxonomy_fields as $taxonomy_field) {
//    if ($taxonomy_field) {
//      $field = $taxonomy_field['field'];
//      $vocabulary = taxonomy_vocabulary_machine_name_load($taxonomy_field['vocabulary']);
//      $options = _nexteuropa_map_viewsgeojson_get_taxonomy_term_options($taxonomy_field['vocabulary']);
//      $form['node_filters']['terms'][$field] = array(
//        '#type' => 'select',
//        '#options' => $options,
//        '#title' => $vocabulary->name,
//        '#multiple' => TRUE,
//        '#description' => t('Filter results by @vocab', array('@vocab' => $vocabulary->name)),
//        '#default_value' => isset($settings['node_filters']['terms'][$field]) ? $settings['node_filters']['terms'][$field] : 0,
//      );
//    }
//  }

  // Provides node status filter.
//  $form['node_filters']['show_unpublished'] = array(
//    '#type' => 'checkbox',
//    '#title' => t('Show unpublished'),
//    '#default_value' => isset($settings['node_filters']['show_unpublished']) ? $settings['node_filters']['show_unpublished'] : 0,
//    '#description' => t('Show unpublished nodes in a map'),
//  );

  // Allows choosing the view mode for displaying the pop-up.
  // @todo make dependent on content type.
//  $entity_info = entity_get_info('node');
//  foreach ($entity_info['view modes'] as $key => $view_mode) {
//    $view_mode_options[$key] = $view_mode['label'];
//  }
//  $form['view_mode'] = array(
//    '#type' => 'select',
//    '#options' => $view_mode_options,
//    '#title' => t('Pop-up view mode'),
//    '#description' => t('View mode to use for the pop-up'),
//    '#default_value' => isset($settings['view_mode']) ? $settings['view_mode'] : 'teaser',
//  );
  return $form;
}

/**
 * Populates a list of views for use in a form select.
 *
 * @return
 *   A list of views that can be used in a form select element.
 */
function _nexteuropa_map_viewsgeojson_get_views() {
  $options = array();

  $views = views_get_all_views();
  dpm($views);

  $vid = taxonomy_vocabulary_machine_name_load($machine_name)->vid;
  $options_source = taxonomy_get_tree($vid);
  foreach ($options_source as $item) {
    $key = $item->tid;
    $value = $item->name;
    $options[$key] = $value;
  }
  return $options;
}


/**
 * Populates a list of terms for use in a form api select.
 *
 * @param string $machine_name
 *   The machine name of the vocabulary
 *
 * @return
 *   A list of terms that can be used in a form select element.
 */
function _nexteuropa_map_viewsgeojson_get_taxonomy_term_options($machine_name) {
  $options = array();
  $vid = taxonomy_vocabulary_machine_name_load($machine_name)->vid;
  $options_source = taxonomy_get_tree($vid);
  foreach ($options_source as $item) {
    $key = $item->tid;
    $value = $item->name;
    $options[$key] = $value;
  }
  return $options;
}

/**
 * Provides list of content types that have a geofield.
 *
 * @return
 *   A list of content types that can be used in a form select element.
 */
function _nexteuropa_map_viewsgeojson_get_content_types() {
  $geofielded_content_types = array();

  // Fetches all the site's content types.
  $content_types = node_type_get_names();

  // Cycles through all the field of the geofield & geofield_geojson type to
  // create a list of content types that use that field.
  $fields = array();
  $fields = $fields + field_read_fields(array('type' => 'geofield', 'entity_type' => 'node'));
  $fields = $fields + field_read_fields(array('type' => 'geofield_geojson', 'entity_type' => 'node'));
  foreach ($fields as $key => $field) {
    $instances = field_read_instances(array('field_name' => $key));
    foreach ($instances as $key => $instance) {
      $geofielded_content_types[$instance['bundle']] = $content_types[$instance['bundle']];
    }
  }
  return $geofielded_content_types;
}




/**
 * Finds geofields in a content type.
 *
 * @return
 *   A list of geofields that can be used in a form select element.
 */
function _nexteuropa_map_viewsgeojson_get_geofields($bundle) {
  $geofields = array();
  $fields = field_read_instances(array('bundle' => $bundle));
  foreach ($fields as $field) {
    $field_info = field_info_field($field['field_name']);
    if (in_array($field_info['type'], array('geofield', 'geofield_geojson'))) {
      $geofields[$field['field_name']] = $field['label'];
    }
  }
  return $geofields;
}

/**
 * Provides list of vocabularies in content types with geofield.
 *
 * @return
 *   A list of taxonomy term fields that are used in content with geofield.
 *
 * @todo add entity reference fields.
 */
function _nexteuropa_map_viewsgeojson_get_taxonomy_fields() {

  $taxnonomy_fields = array();
  // Cycles through all the fields of all the content types that contains
  // geofield to find vocabularies.
  $content_types = _nexteuropa_map_viewsgeojson_get_content_types();
  foreach ($content_types as $key => $content_type) {
    $fields = field_read_instances(array('bundle' => $key));
    foreach ($fields as $field) {
      $field_info = field_info_field($field['field_name']);
      if ($field_info['type'] == 'taxonomy_term_reference') {
        foreach ($field_info['settings']['allowed_values'] as $allowed_value) {
          $taxnonomy_fields[] = array(
            'vocabulary' => $allowed_value['vocabulary'],
            'field' => $field_info['field_name'],
          );
        }
      }
    }
  }
  return $taxnonomy_fields;
}

/**
 * Fetches nodes.
 *
 * @param array $filters
 *   List of query conditions.
 *
 * @return array List of NIDs of nodes that match the filters.
 *   List of IDs of nodes that match the filters.
 */
function _nexteuropa_map_viewsgeojson_fetch_viewsgeojsons($filters) {
  if ($filters['map_content_type']) {
    $nodes = array();
    $query = new EntityFieldQuery();

    // Filters result by bundle.
    $query->entityCondition('entity_type', 'node')
      // @todo clean up.
      // ->addTag('efq_debug')
      ->entityCondition('bundle', $filters['map_content_type']);

    // Fetches the geofields in the content type and filters out nodes that
    // have an empty geofield. The column differs per geofield type.
    if ($filters['geofield']) {
      $type = field_info_field($filters['geofield'])['type'];
      if ($type == 'geofield') {
        $query->fieldCondition($filters['geofield'], 'lat', 'NULL', '!=');
      }
      elseif ($type == 'geofield_geojson') {
        $query->fieldCondition($filters['geofield'], 'geofield_geojson', 'NULL', '!=');
      }
    }

    // Allows including unpublished nodes in the result.
    if ($filters['show_unpublished'] == TRUE) {
      $query->propertyCondition('status', array(0, 1), 'in');
    }
    else {
      $query->propertyCondition('status', 1);
    }

    // Applies chosen taxonomy terms filters.
    if (isset($filters['terms'])) {
      foreach ($filters['terms'] as $term_field => $tids) {
        if (count($tids) > 0) {
          $query->fieldCondition($term_field, 'tid', $tids, 'in');
        }
      }
    }

    // Runs the query and loads the nodes.
    $result = $query->execute();
    if (isset($result['node'])) {
      $nids = array_keys($result['node']);
      $nodes = entity_load('node', $nids);
    }
    return $nodes;
  }
  else {
    drupal_set_message('Not enough information to build map.', 'error');
  }
}

/**
 * Turns field items into GeoJSON features.
 *
 * @param array $items
 *   Field values.
 *
 * @return
 *   An array containing a GeoJSON formatted map feature.
 *
 * Shameless copy from leaflet_process_geofield().
 */
function _nexteuropa_map_viewsgeojson_prepare_features($items = array()) {
  $features = array();
  geophp_load();
  foreach ($items as $item) {
    foreach ($item['field_items'] as $delta => $field_item) {

      // Translate linestring to polyline:
      if ($field_item['geo_type'] == 'multilinestring') {
        $field_item['geo_type'] = 'multipolyline';
      }
      // Geofield 7.x-2.x compatibility.
      if (!isset($field_item['wkt']) && isset($field_item['geom'])) {
        $field_item['wkt'] = $field_item['geom'];
      }
      $geom = geoPHP::load($field_item['wkt'], 'wkt');
      $type = get_class($geom);
      switch ($field_item['geo_type']) {
        // Formats single features.
        case 'point':
        case 'polygon':
        case 'linestring':
          $geofeature = new MapeditorGeoFeature($type, $geom);
          if (isset($item['title']) && isset($item['popup'])) {
            $geofeature->setProperties($item['title'], $item['popup']);
          }
          $geofeature->setGeometry($type, $geom);
          $features[] = $geofeature->data;
          break;

        // Formates multiple features of the same type.
        case 'multipolyline':
        case 'multipolygon':
        case 'multipoint':
          $components = $geom->getComponents();
          foreach ($components as $component) {
            $class = get_class($component);
            $geofeature = new MapeditorGeoFeature();
            if (isset($item['title']) && isset($item['popup'])) {
              $geofeature->setProperties($item['title'], $item['popup']);
            }
            $geofeature->setGeometry($class, $component);
            $features[] = $geofeature->data;
          }
          break;

        // Formates multiple features of mixed types.
        // @todo merge with other multiple?
        case 'geometrycollection':
          $components = $geom->getComponents();
          foreach ($components as $component) {
            $class = get_class($component);
            $geofeature = new MapeditorGeoFeature($class, $component);
            if (isset($item['title']) && isset($item['popup'])) {
              $geofeature->setProperties($item['title'], $item['popup']);
            }
            $geofeature->setGeometry($class, $component);
            $features[] = $geofeature->data;
          }
          break;

      }
    }
  }
  return array(
    "type" => "FeatureCollection",
    "features" => $features,
  );
}

/**
 * Implements hook_map_layer_settings_alter().
 *
 * See MapLayerInlineEntityFormController->entityFormSubmit() and
 * nexteuropa_map_layer_form_submit().
 */
function nexteuropa_map_viewsgeojson_map_layer_settings_alter(&$settings, $map_layer) {
  if ($map_layer->type == 'viewsgeojson_layer') {
    $settings['attribution'] = $map_layer->attribution;
    $settings['popup'] = $map_layer->popup;
    $settings['icon'] = $map_layer->icon;
    $settings['control'] = $map_layer->control;
    $settings['clustering'] = $map_layer->clustering;
    $settings['view'] = $map_layer->view;
  }
  return $settings;
}

/**
 * Implements hook_stand_alone_map_layer_settings_alter().
 *
 * See nexteuropa_map_layer_form_submit().
 *
 * @todo merge with nexteuropa_map_viewsgeojson_map_layer_settings_alter.
 */
function nexteuropa_map_viewsgeojson_stand_alone_map_layer_settings_alter(&$settings, $form_state) {
  if ($form_state['map_layer']->type == 'viewsgeojson_layer') {
    $values = $form_state['values'];
    $settings['attribution'] = $values['attribution'];
    $settings['popup'] = $values['popup'];
    $settings['icon'] = $values['icon'];
    $settings['control'] = $values['control'];
    $settings['clustering'] = $values['clustering'];
    $settings['view'] = $values['view'];
  }
  return $settings;
}
